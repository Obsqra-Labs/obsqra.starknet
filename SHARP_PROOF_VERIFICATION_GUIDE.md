# How to Verify a Real Proof in SHARP Registry

## Current Flow

### Step 1: Generate Proof
```python
# Backend generates proof via LuminAIR/Stone
proof = await generate_risk_proof(metrics)
# Returns: proof JSON, fact_hash, etc.
```

### Step 2: Submit to Integrity (Herodotus)
```python
# Backend submits proof to Integrity FactRegistry
integrity = IntegrityService(rpc_url, network="sepolia")
result = await integrity.verify_proof_full_and_register_fact(
    verifier_config,
    stark_proof
)
# This registers the proof in the FactRegistry contract
```

### Step 3: Get Fact Hash
```python
# After verification, get the fact hash
fact_hash = integrity.get_verification_hash(proof_hash)
# This is what gets stored in SHARP registry
```

### Step 4: Verify in Contract
```cairo
// In RiskEngine contract
let registry = IFactRegistryDispatcher { 
    contract_address: fact_registry_address 
};

// Check if proof is verified
let verifications = registry.get_all_verifications_for_fact_hash(proof_fact);
let len = verifications.len();
if len == 0 {
    return false; // Not verified
}
// Verified if array is non-empty
```

---

## Complete End-to-End Flow

### Backend Side (Python)

1. **Generate Proof**:
   ```python
   # Use LuminAIR or Stone prover
   proof_job = await generate_proof(metrics)
   ```

2. **Submit to Integrity**:
   ```python
   integrity = get_integrity_service()
   verified = await integrity.verify_proof_full_and_register_fact(
       verifier_config=proof_job.verifier_config,
       stark_proof=proof_job.proof_json
   )
   
   if verified:
       fact_hash = proof_job.fact_hash
       # This fact_hash is now in SHARP registry
   ```

3. **Pass to Contract**:
   ```python
   # In orchestrate_allocation
   calldata = [
       # ... metrics ...
       fact_hash,  # The verified fact hash
       expected_score,
       # ...
   ]
   ```

### Contract Side (Cairo)

```cairo
// In propose_and_execute_allocation
let proofs_valid = verify_allocation_decision_with_proofs(
    jediswap_metrics,
    ekubo_metrics,
    jediswap_proof_fact,  // From backend
    ekubo_proof_fact,     // From backend
    expected_jediswap_score,
    expected_ekubo_score,
    fact_registry_address  // SHARP registry
);

assert(proofs_valid, 0); // Reject if not verified
```

---

## What Makes a "Real" Proof?

A proof is "real" and verifiable when:

1. ✅ **Generated by valid prover** (LuminAIR/Stone)
2. ✅ **Submitted to Integrity** via `verify_proof_full_and_register_fact`
3. ✅ **Registered in FactRegistry** (returns fact_hash)
4. ✅ **Queryable on-chain** via `get_all_verifications_for_fact_hash`

---

## Current Status

**What Works**:
- ✅ Proof generation (LuminAIR/Stone)
- ✅ Integrity service integration
- ✅ Contract verification logic
- ✅ FactRegistry interface

**What's Needed**:
- ⚠️ Proof must be submitted to Integrity first
- ⚠️ Fact hash must be registered before contract call
- ⚠️ Current test fails because proof isn't in registry yet

---

## Testing with Real Proof

### Option 1: Use Existing Verified Proof
```python
# If you have a proof that's already verified:
fact_hash = "0x..."  # Known verified fact hash
# Use this in contract call
```

### Option 2: Generate and Verify First
```python
# 1. Generate proof
proof = await generate_proof(metrics)

# 2. Submit to Integrity (this takes time)
verified = await integrity.verify_proof_full_and_register_fact(...)

# 3. Wait for verification (async)
# 4. Then call contract with fact_hash
```

### Option 3: Mock for Testing
```python
# For immediate testing, you can:
# 1. Generate proof
# 2. Skip Integrity submission (for now)
# 3. Use mock fact_hash
# 4. Test contract logic separately
```

---

## Next Steps

1. **Generate a real proof** via LuminAIR/Stone
2. **Submit to Integrity** and wait for verification
3. **Get fact_hash** from verification result
4. **Use fact_hash** in contract call
5. **Contract verifies** via `get_all_verifications_for_fact_hash`

The key is: **Proof must be in registry BEFORE contract checks it**.
