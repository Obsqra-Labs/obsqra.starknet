# V1.3 Implementation Plan - Privacy Pool MVP

## Goal

**Demonstrable lightweight privacy pool with verifiable AI optimization**

Users can deposit USDC, pool optimizes across Jedi/Ekubo with cryptographic proofs, users earn yield and withdraw.

**Timeline**: 3-4 weeks

---

## Week 1: Core Pool Contract

### SharedPool.cairo

```cairo
#[starknet::contract]
mod SharedPool {
    use starknet::ContractAddress;
    use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
    
    #[storage]
    struct Storage {
        // Pool token
        total_shares: u256,
        user_shares: LegacyMap<ContractAddress, u256>,
        
        // Assets
        base_token: ContractAddress,  // USDC
        total_deposited: u256,
        
        // Strategy
        strategy_router: ContractAddress,
        risk_engine: ContractAddress,
        
        // Performance
        last_rebalance: u64,
        total_rebalances: u64,
        cumulative_return: u256,
    }
    
    #[external(v0)]
    fn deposit(ref self: ContractState, amount: u256) -> u256 {
        // 1. Transfer USDC from user
        let caller = get_caller_address();
        let token = IERC20Dispatcher { contract_address: self.base_token.read() };
        token.transfer_from(caller, get_contract_address(), amount);
        
        // 2. Calculate shares
        let shares = if self.total_shares.read() == 0 {
            amount  // First deposit: 1:1
        } else {
            // shares = amount * total_shares / total_value
            let total_value = self.get_total_value();
            (amount * self.total_shares.read()) / total_value
        };
        
        // 3. Mint shares
        self.total_shares.write(self.total_shares.read() + shares);
        self.user_shares.write(caller, self.user_shares.read(caller) + shares);
        self.total_deposited.write(self.total_deposited.read() + amount);
        
        // 4. Emit event
        self.emit(Deposit { user: caller, amount, shares });
        
        shares
    }
    
    #[external(v0)]
    fn withdraw(ref self: ContractState, shares: u256) -> u256 {
        // 1. Verify user has shares
        let caller = get_caller_address();
        assert(self.user_shares.read(caller) >= shares, 'Insufficient shares');
        
        // 2. Calculate amount
        let total_value = self.get_total_value();
        let amount = (shares * total_value) / self.total_shares.read();
        
        // 3. Burn shares
        self.user_shares.write(caller, self.user_shares.read(caller) - shares);
        self.total_shares.write(self.total_shares.read() - shares);
        
        // 4. Withdraw from strategy if needed
        self._ensure_liquidity(amount);
        
        // 5. Transfer USDC to user
        let token = IERC20Dispatcher { contract_address: self.base_token.read() };
        token.transfer(caller, amount);
        
        // 6. Emit event
        self.emit(Withdraw { user: caller, amount, shares });
        
        amount
    }
    
    #[external(v0)]
    fn rebalance_with_proof(
        ref self: ContractState,
        jediswap_pct: u64,
        ekubo_pct: u64,
        proof_hash: felt252
    ) {
        // Only strategy executor
        assert(get_caller_address() == self.strategy_router.read(), 'Unauthorized');
        
        // Get current allocations
        let current = self.get_current_allocations();
        
        // Execute rebalance
        let router = IStrategyRouterDispatcher { 
            contract_address: self.strategy_router.read() 
        };
        router.rebalance(jediswap_pct, ekubo_pct);
        
        // Update state
        self.last_rebalance.write(get_block_timestamp());
        self.total_rebalances.write(self.total_rebalances.read() + 1);
        
        // Emit event
        self.emit(Rebalance {
            timestamp: get_block_timestamp(),
            jediswap_pct,
            ekubo_pct,
            proof_hash,
            total_value: self.get_total_value()
        });
    }
    
    #[view]
    fn get_total_value(self: @ContractState) -> u256 {
        // Total value = idle + deployed
        let idle = self.get_idle_balance();
        let deployed = self.get_deployed_value();
        idle + deployed
    }
    
    #[view]
    fn get_deployed_value(self: @ContractState) -> u256 {
        // Query strategy router for deployed capital
        let router = IStrategyRouterDispatcher { 
            contract_address: self.strategy_router.read() 
        };
        router.get_total_value()
    }
    
    #[view]
    fn get_user_value(self: @ContractState, user: ContractAddress) -> u256 {
        let shares = self.user_shares.read(user);
        if shares == 0 {
            return 0;
        }
        let total_value = self.get_total_value();
        (shares * total_value) / self.total_shares.read()
    }
    
    #[view]
    fn calculate_apy(self: @ContractState) -> u256 {
        // Simple APY: (current_value - deposited) / deposited * (365 days / time_elapsed)
        let current_value = self.get_total_value();
        let deposited = self.total_deposited.read();
        
        if deposited == 0 {
            return 0;
        }
        
        // This is simplified - real APY needs more complex calculation
        let gain = if current_value > deposited {
            current_value - deposited
        } else {
            0
        };
        
        (gain * 10000) / deposited  // Return as basis points
    }
}
```

**Deploy**:
```bash
cd contracts
scarb build
sncast declare --contract-name SharedPool
sncast deploy --class-hash <hash> --constructor-calldata <token>,<router>,<engine>
```

---

## Week 2: Backend Orchestration

### pool_service.py

```python
"""Pool management and optimization service"""
from decimal import Decimal
from typing import Dict, List
from starknet_py.contract import Contract
from app.services.luminair_service import get_luminair_service

class PoolService:
    def __init__(self, pool_contract: Contract):
        self.pool = pool_contract
    
    async def get_pool_state(self) -> Dict:
        """Get current pool state from contract"""
        total_value = await self.pool.functions["get_total_value"].call()
        total_shares = await self.pool.functions["total_shares"].call()
        deployed = await self.pool.functions["get_deployed_value"].call()
        apy = await self.pool.functions["calculate_apy"].call()
        
        return {
            "total_value": total_value.total_value,
            "total_shares": total_shares.total_shares,
            "deployed_value": deployed.deployed,
            "idle_value": total_value.total_value - deployed.deployed,
            "apy": apy.apy / 10000,  # Convert from basis points
            "share_price": total_value.total_value / total_shares.total_shares if total_shares.total_shares > 0 else 1.0
        }
    
    async def get_current_allocations(self) -> Dict:
        """Get current protocol allocations"""
        # Query strategy router
        router = await self._get_router_contract()
        jedi = await router.functions["get_jediswap_allocation"].call()
        ekubo = await router.functions["get_ekubo_allocation"].call()
        
        return {
            "jediswap": jedi.allocation,
            "ekubo": ekubo.allocation
        }
    
    async def calculate_optimal_allocation(self) -> Dict:
        """AI determines optimal allocation based on current metrics"""
        # 1. Get protocol metrics (from oracles or APIs)
        jedi_metrics = await self._get_protocol_metrics("jediswap")
        ekubo_metrics = await self._get_protocol_metrics("ekubo")
        
        # 2. Calculate risk scores
        from app.services.luminair_service import get_luminair_service
        luminair = get_luminair_service()
        
        proof = await luminair.generate_proof(jedi_metrics, ekubo_metrics)
        
        # 3. Convert risk scores to allocations
        # Lower risk = higher allocation (inverse relationship)
        jedi_weight = 1.0 / proof.output_score_jediswap
        ekubo_weight = 1.0 / proof.output_score_ekubo
        total_weight = jedi_weight + ekubo_weight
        
        jedi_pct = int((jedi_weight / total_weight) * 10000)
        ekubo_pct = 10000 - jedi_pct
        
        return {
            "jediswap_pct": jedi_pct,
            "ekubo_pct": ekubo_pct,
            "proof_hash": proof.proof_hash,
            "jediswap_risk": proof.output_score_jediswap,
            "ekubo_risk": proof.output_score_ekubo
        }
    
    async def execute_rebalance_with_proof(self, allocation: Dict) -> str:
        """Execute rebalance on-chain with proof"""
        # Call pool contract's rebalance_with_proof
        result = await self.pool.functions["rebalance_with_proof"].invoke(
            jediswap_pct=allocation["jediswap_pct"],
            ekubo_pct=allocation["ekubo_pct"],
            proof_hash=int(allocation["proof_hash"], 16)
        )
        
        return result.transaction_hash

# Add to routes/pool.py
@router.post("/optimize")
async def optimize_pool():
    """Trigger pool optimization"""
    pool_service = get_pool_service()
    
    # 1. Calculate optimal allocation
    allocation = await pool_service.calculate_optimal_allocation()
    
    # 2. Execute with proof
    tx_hash = await pool_service.execute_rebalance_with_proof(allocation)
    
    return {
        "tx_hash": tx_hash,
        "allocation": allocation,
        "status": "rebalancing"
    }

@router.get("/state")
async def get_pool_state():
    """Get current pool state"""
    pool_service = get_pool_service()
    return await pool_service.get_pool_state()

@router.get("/performance")
async def get_performance():
    """Get historical performance"""
    # Query RebalanceHistory from contract events
    events = await get_rebalance_events()
    
    return {
        "apy": await calculate_apy_from_events(events),
        "rebalances": [
            {
                "timestamp": e.timestamp,
                "jediswap_pct": e.jediswap_pct,
                "ekubo_pct": e.ekubo_pct,
                "proof_hash": hex(e.proof_hash),
                "total_value": e.total_value
            }
            for e in events
        ]
    }
```

---

## Week 3: Frontend Refactor (Remove Demo Mode)

### Audit: Find All Demo Code

```bash
cd frontend
grep -r "mock\|demo\|fake\|dummy\|placeholder" src/
```

**Files to update**:
- `src/hooks/useStrategyDeposit.ts` - Remove mock deposits
- `src/components/Dashboard.tsx` - Remove demo data
- `src/components/PerformanceChart.tsx` - Remove mock chart data
- `src/app/page.tsx` - Remove demo toggles

### New Components (Real Data Only)

#### 1. PoolOverview.tsx

```typescript
import { usePoolState } from '@/hooks/usePoolState';
import { useAccount } from '@starknet-react/core';

export function PoolOverview() {
  const { address } = useAccount();
  const { state, loading } = usePoolState();
  
  if (loading) return <Skeleton />;
  
  return (
    <div className="grid grid-cols-4 gap-4">
      <Card>
        <Label>Total Value Locked</Label>
        <Value>${formatUSD(state.total_value)}</Value>
      </Card>
      
      <Card>
        <Label>Current APY</Label>
        <Value>{state.apy.toFixed(2)}%</Value>
      </Card>
      
      <Card>
        <Label>Your Balance</Label>
        <Value>${formatUSD(state.user_value)}</Value>
      </Card>
      
      <Card>
        <Label>Your Shares</Label>
        <Value>{state.user_shares.toFixed(4)}</Value>
      </Card>
    </div>
  );
}
```

#### 2. DepositWithdrawPanel.tsx

```typescript
export function DepositWithdrawPanel() {
  const { deposit, withdraw } = usePool();
  const [amount, setAmount] = useState('');
  const [mode, setMode] = useState<'deposit' | 'withdraw'>('deposit');
  
  const handleDeposit = async () => {
    const tx = await deposit(parseUnits(amount, 6)); // USDC has 6 decimals
    await waitForTransaction(tx);
    toast.success('Deposit successful!');
  };
  
  const handleWithdraw = async () => {
    const shares = calculateShares(amount);
    const tx = await withdraw(shares);
    await waitForTransaction(tx);
    toast.success('Withdrawal successful!');
  };
  
  return (
    <Card>
      <Tabs value={mode} onChange={setMode}>
        <Tab value="deposit">Deposit</Tab>
        <Tab value="withdraw">Withdraw</Tab>
      </Tabs>
      
      <Input
        type="number"
        value={amount}
        onChange={(e) => setAmount(e.target.value)}
        placeholder="Amount (USDC)"
      />
      
      <Button
        onClick={mode === 'deposit' ? handleDeposit : handleWithdraw}
        disabled={!amount}
      >
        {mode === 'deposit' ? 'Deposit' : 'Withdraw'}
      </Button>
    </Card>
  );
}
```

#### 3. RebalanceHistory.tsx

```typescript
export function RebalanceHistory() {
  const { rebalances, loading } = useRebalanceHistory();
  
  if (loading) return <Skeleton />;
  
  return (
    <Card>
      <h3>Rebalance History</h3>
      <Table>
        <thead>
          <tr>
            <th>Time</th>
            <th>Allocation</th>
            <th>Proof</th>
            <th>Status</th>
            <th>TX</th>
          </tr>
        </thead>
        <tbody>
          {rebalances.map((r) => (
            <tr key={r.tx_hash}>
              <td>{formatTimestamp(r.timestamp)}</td>
              <td>
                Jedi {r.jediswap_pct/100}% / Ekubo {r.ekubo_pct/100}%
              </td>
              <td>
                <code>{r.proof_hash.slice(0, 10)}...</code>
                <ProofBadge verified={r.verified} />
              </td>
              <td>
                <StatusBadge status={r.status} />
              </td>
              <td>
                <Link
                  href={`https://sepolia.voyager.online/tx/${r.tx_hash}`}
                  target="_blank"
                >
                  View
                </Link>
              </td>
            </tr>
          ))}
        </tbody>
      </Table>
    </Card>
  );
}
```

#### 4. ProofTimeline.tsx

```typescript
export function ProofTimeline({ proofJobId }: { proofJobId: string }) {
  const { job, loading } = useProofJob(proofJobId);
  
  if (loading) return <Skeleton />;
  
  return (
    <Timeline>
      <Step
        status={job.status === 'generating' ? 'active' : 'complete'}
        title="Analyzing Protocols"
      >
        Calculating optimal allocation...
      </Step>
      
      <Step
        status={
          job.status === 'generated' ? 'active' :
          job.status === 'generating' ? 'pending' :
          'complete'
        }
        title="Generating Proof"
      >
        STARK proof: {job.proof_hash?.slice(0, 10)}...
        <Badge>Verified Locally</Badge>
      </Step>
      
      <Step
        status={
          job.status === 'submitted' ? 'active' :
          ['generating', 'generated'].includes(job.status) ? 'pending' :
          'complete'
        }
        title="Executing Rebalance"
      >
        {job.tx_hash && (
          <Link href={`https://sepolia.voyager.online/tx/${job.tx_hash}`}>
            TX: {job.tx_hash.slice(0, 10)}...
          </Link>
        )}
      </Step>
      
      <Step
        status={
          job.status === 'verifying' ? 'active' :
          job.status === 'verified' ? 'complete' :
          'pending'
        }
        title="SHARP Verification"
      >
        {job.sharp_job_id ? (
          <>Submitted to SHARP (est. {job.estimated_completion}min)</>
        ) : (
          <>Pending submission...</>
        )}
      </Step>
      
      {job.status === 'verified' && (
        <Step status="complete" title="L1 Verified">
          Fact hash: {job.fact_hash?.slice(0, 10)}...
          <Link href={`https://etherscan.io/address/sharp_verifier#readContract`}>
            View on L1
          </Link>
        </Step>
      )}
    </Timeline>
  );
}
```

### Hooks (Real Contract Calls)

```typescript
// hooks/usePoolState.ts
export function usePoolState() {
  const { data: state, isLoading } = useContractRead({
    address: POOL_ADDRESS,
    abi: poolAbi,
    functionName: 'get_total_value',
  });
  
  // Also get user-specific data
  const { address } = useAccount();
  const { data: userValue } = useContractRead({
    address: POOL_ADDRESS,
    abi: poolAbi,
    functionName: 'get_user_value',
    args: [address],
  });
  
  return {
    state: {
      total_value: state?.total_value || 0n,
      user_value: userValue?.user_value || 0n,
      // ... other fields
    },
    loading: isLoading
  };
}

// hooks/usePool.ts
export function usePool() {
  const { contract } = useContract({
    address: POOL_ADDRESS,
    abi: poolAbi,
  });
  
  const deposit = async (amount: bigint) => {
    // 1. Approve USDC
    const usdcContract = getContract(USDC_ADDRESS, erc20Abi);
    await usdcContract.approve(POOL_ADDRESS, amount);
    
    // 2. Deposit
    return await contract.deposit(amount);
  };
  
  const withdraw = async (shares: bigint) => {
    return await contract.withdraw(shares);
  };
  
  return { deposit, withdraw };
}

// hooks/useRebalanceHistory.ts
export function useRebalanceHistory() {
  const { data: events, isLoading } = useContractEvents({
    address: POOL_ADDRESS,
    abi: poolAbi,
    eventName: 'Rebalance',
    from_block: 0,
  });
  
  return {
    rebalances: events?.map(e => ({
      timestamp: e.timestamp,
      jediswap_pct: e.jediswap_pct,
      ekubo_pct: e.ekubo_pct,
      proof_hash: e.proof_hash,
      tx_hash: e.transaction_hash,
      verified: true, // Check against proof_jobs table
    })) || [],
    loading: isLoading
  };
}
```

---

## Week 4: Integration + Testing

### End-to-End Test

```typescript
describe('Pool E2E', () => {
  it('full user journey', async () => {
    // 1. Deposit
    const depositTx = await pool.deposit(1000_000000n); // 1000 USDC
    await waitForTransaction(depositTx);
    
    const shares = await pool.user_shares(user.address);
    expect(shares).toBeGreaterThan(0n);
    
    // 2. Trigger rebalance
    const rebalanceTx = await backend.post('/api/v1/pool/optimize');
    expect(rebalanceTx.status).toBe(200);
    
    // 3. Wait for proof generation
    const proofJob = await waitForProof(rebalanceTx.data.proof_job_id);
    expect(proofJob.status).toBe('generated');
    expect(proofJob.proof_hash).toBeDefined();
    
    // 4. Verify rebalance executed
    const allocation = await pool.get_current_allocations();
    expect(allocation.jediswap + allocation.ekubo).toBe(10000);
    
    // 5. Check performance updated
    const performance = await backend.get('/api/v1/pool/performance');
    expect(performance.data.rebalances.length).toBeGreaterThan(0);
    
    // 6. Withdraw
    const withdrawTx = await pool.withdraw(shares);
    await waitForTransaction(withdrawTx);
    
    const finalShares = await pool.user_shares(user.address);
    expect(finalShares).toBe(0n);
  });
});
```

---

## Deliverables Checklist

### Week 1
- [ ] SharedPool.cairo contract written
- [ ] Deployed to Sepolia
- [ ] Basic deposit/withdraw working
- [ ] Integration with StrategyRouter

### Week 2
- [ ] PoolService backend implementation
- [ ] API endpoints (/pool/state, /pool/optimize, /pool/performance)
- [ ] Proof generation integrated with rebalance
- [ ] Performance calculation working

### Week 3
- [ ] Demo mode completely removed
- [ ] PoolOverview component (real data)
- [ ] DepositWithdraw component (real transactions)
- [ ] RebalanceHistory component (on-chain events)
- [ ] ProofTimeline component (proof visualization)

### Week 4
- [ ] End-to-end testing complete
- [ ] Error handling implemented
- [ ] Loading states polished
- [ ] Documentation updated

---

## Success Criteria

**V1.3 is complete when**:

1. User can deposit real USDC and get shares
2. Pool rebalances automatically with AI optimization
3. Every rebalance generates a STARK proof (visible in UI)
4. Performance is calculated from on-chain data
5. User can see all historical rebalances with proofs
6. User can withdraw shares and receive USDC + yield
7. NO demo mode exists anywhere in frontend
8. Everything works end-to-end on Sepolia testnet

**Measurement**:
- 10 test users successfully deposit
- 7 days of automated rebalances
- All proofs generated and verified
- APY calculated from real returns
- 0 instances of mock/demo data

---

## MIST Integration (V1.4)

**After V1.3 stable, add privacy**:

1. Replace SharedPool with PrivatePool
2. Deposit with commitment (nullifier)
3. Withdraw with ZK proof
4. Keep optimization transparent
5. Individual balances hidden

**Timeline**: 1-2 months after V1.3

---

**Current Focus**: Week 1 - Deploy SharedPool contract

**Next**: Write SharedPool.cairo, deploy to Sepolia, test deposit/withdraw

